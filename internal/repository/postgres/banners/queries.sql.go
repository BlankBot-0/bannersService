// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package banners

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addBannerTags = `-- name: AddBannerTags :exec
INSERT INTO banners_tag (banner_id, tag_id)
VALUES ($1, UNNEST($2))
`

type AddBannerTagsParams struct {
	BannerID pgtype.Int4
	Unnest   interface{}
}

func (q *Queries) AddBannerTags(ctx context.Context, arg AddBannerTagsParams) error {
	_, err := q.db.Exec(ctx, addBannerTags, arg.BannerID, arg.Unnest)
	return err
}

const checkActiveUserBanner = `-- name: CheckActiveUserBanner :one
SELECT banners.is_active
FROM banners
    JOIN banners_tag
        ON banners.id = banners_tag.banner_id
WHERE
    banners_tag.tag_id = $1 AND banners.feature_id = $2
`

type CheckActiveUserBannerParams struct {
	TagID     pgtype.Int4
	FeatureID int32
}

func (q *Queries) CheckActiveUserBanner(ctx context.Context, arg CheckActiveUserBannerParams) (pgtype.Bool, error) {
	row := q.db.QueryRow(ctx, checkActiveUserBanner, arg.TagID, arg.FeatureID)
	var is_active pgtype.Bool
	err := row.Scan(&is_active)
	return is_active, err
}

const checkBannerId = `-- name: CheckBannerId :one

SELECT EXISTS(SELECT id FROM banners WHERE id = $1)
`

// should default to 1 if $4 is NULL
func (q *Queries) CheckBannerId(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRow(ctx, checkBannerId, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createBanner = `-- name: CreateBanner :one
INSERT INTO banners (feature_id, is_active, created_at)
VALUES ($1, $2, NOW())
RETURNING id
`

type CreateBannerParams struct {
	FeatureID int32
	IsActive  pgtype.Bool
}

func (q *Queries) CreateBanner(ctx context.Context, arg CreateBannerParams) (int32, error) {
	row := q.db.QueryRow(ctx, createBanner, arg.FeatureID, arg.IsActive)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createBannerInfo = `-- name: CreateBannerInfo :exec
INSERT INTO banners_info (banner_id, updated_at, contents)
VALUES ($1, NOW(), $2)
`

type CreateBannerInfoParams struct {
	BannerID pgtype.Int4
	Contents []byte
}

func (q *Queries) CreateBannerInfo(ctx context.Context, arg CreateBannerInfoParams) error {
	_, err := q.db.Exec(ctx, createBannerInfo, arg.BannerID, arg.Contents)
	return err
}

const deleteBannerInfo = `-- name: DeleteBannerInfo :exec
DELETE FROM banners_info
WHERE banner_id = $1
`

func (q *Queries) DeleteBannerInfo(ctx context.Context, bannerID pgtype.Int4) error {
	_, err := q.db.Exec(ctx, deleteBannerInfo, bannerID)
	return err
}

const deleteBannerTags = `-- name: DeleteBannerTags :exec
DELETE FROM banners_tag
WHERE banner_id = $1
`

func (q *Queries) DeleteBannerTags(ctx context.Context, bannerID pgtype.Int4) error {
	_, err := q.db.Exec(ctx, deleteBannerTags, bannerID)
	return err
}

const getUserBanner = `-- name: GetUserBanner :one
SELECT banners_info.contents
FROM banners
    JOIN banners_tag
        ON banners.id = banners_tag.banner_id
    JOIN banners_info
        ON banners_tag.banner_id = banners_info.banner_id
WHERE
    banners_tag.tag_id = $1 AND banners.feature_id = $2
ORDER BY
    banners_info.updated_at
        DESC LIMIT 1
`

type GetUserBannerParams struct {
	TagID     pgtype.Int4
	FeatureID int32
}

func (q *Queries) GetUserBanner(ctx context.Context, arg GetUserBannerParams) ([]byte, error) {
	row := q.db.QueryRow(ctx, getUserBanner, arg.TagID, arg.FeatureID)
	var contents []byte
	err := row.Scan(&contents)
	return contents, err
}

const listBannerVersions = `-- name: ListBannerVersions :many

SELECT banners.id, banners.feature_id,
       banners_info.contents, banners.is_active,
       banners.created_at, banners_info.updated_at
FROM banners
     JOIN banners_tag
          ON banners.id = banners_tag.banner_id
     JOIN banners_info
          ON banners_tab.banner_id = banners_info.banner_id
WHERE
    banners_tag.tag_id = $1 OR $1 IS NULL
    AND banners.feature_id = $2 OR $2 IS NULL
    LIMIT $3   -- should default to inf if $4 is NULL
OFFSET $4
`

type ListBannerVersionsParams struct {
	TagID     pgtype.Int4
	FeatureID int32
	Limit     int32
	Offset    int32
}

type ListBannerVersionsRow struct {
	ID        int32
	FeatureID int32
	Contents  []byte
	IsActive  pgtype.Bool
	CreatedAt pgtype.Timestamp
	UpdatedAt pgtype.Timestamp
}

// should default to 1 if $4 is NULL
func (q *Queries) ListBannerVersions(ctx context.Context, arg ListBannerVersionsParams) ([]ListBannerVersionsRow, error) {
	rows, err := q.db.Query(ctx, listBannerVersions,
		arg.TagID,
		arg.FeatureID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBannerVersionsRow
	for rows.Next() {
		var i ListBannerVersionsRow
		if err := rows.Scan(
			&i.ID,
			&i.FeatureID,
			&i.Contents,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBanners = `-- name: ListBanners :many
SELECT banners.id, banners.feature_id,
       banners_info.contents, banners.is_active,
       banners.created_at, banners_info.updated_at,
       tags_arr.tags,
       RANK() OVER (PARTITION BY banners_tag.tag_id, banners.feature_id
                    ORDER BY banners_info.updated_at DESC) rn
FROM banners
    JOIN banners_tag
        ON banners.id = banners_tag.banner_id
    JOIN banners_info
        ON banners_tab.banner_id = banners_info.banner_id
    JOIN (
        SELECT banners.id, array_agg(banners_tag.tag_id) as tags
        FROM banners
        JOIN banners_tag
            ON banner.id = banners_tag.banner_id
        GROUP BY banners.id
    ) tags_arr
        ON banners.id = tags_arr.id
WHERE
    banners_tag.tag_id = $1 OR $1 IS NULL
    AND banners.feature_id = $2 OR $2 IS NULL
    AND rn = 1
LIMIT $3   -- should default to inf if $4 is NULL
OFFSET $4
`

type ListBannersParams struct {
	TagID     pgtype.Int4
	FeatureID int32
	Limit     int32
	Offset    int32
}

type ListBannersRow struct {
	ID        int32
	FeatureID int32
	Contents  []byte
	IsActive  pgtype.Bool
	CreatedAt pgtype.Timestamp
	UpdatedAt pgtype.Timestamp
	Tags      interface{}
	Rn        int64
}

func (q *Queries) ListBanners(ctx context.Context, arg ListBannersParams) ([]ListBannersRow, error) {
	rows, err := q.db.Query(ctx, listBanners,
		arg.TagID,
		arg.FeatureID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBannersRow
	for rows.Next() {
		var i ListBannersRow
		if err := rows.Scan(
			&i.ID,
			&i.FeatureID,
			&i.Contents,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Tags,
			&i.Rn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBannerContents = `-- name: UpdateBannerContents :exec
INSERT INTO banners_info (banner_id, updated_at, contents)
VALUES ($1, NOW(), $2)
`

type UpdateBannerContentsParams struct {
	BannerID pgtype.Int4
	Contents []byte
}

func (q *Queries) UpdateBannerContents(ctx context.Context, arg UpdateBannerContentsParams) error {
	_, err := q.db.Exec(ctx, updateBannerContents, arg.BannerID, arg.Contents)
	return err
}

const updateBannerFeature = `-- name: UpdateBannerFeature :exec
UPDATE banners
SET feature_id = $2
WHERE id = $1
`

type UpdateBannerFeatureParams struct {
	ID        int32
	FeatureID int32
}

func (q *Queries) UpdateBannerFeature(ctx context.Context, arg UpdateBannerFeatureParams) error {
	_, err := q.db.Exec(ctx, updateBannerFeature, arg.ID, arg.FeatureID)
	return err
}

const updateBannerIsActive = `-- name: UpdateBannerIsActive :exec
UPDATE banners
SET is_active = $2
WHERE id = $1
`

type UpdateBannerIsActiveParams struct {
	ID       int32
	IsActive pgtype.Bool
}

func (q *Queries) UpdateBannerIsActive(ctx context.Context, arg UpdateBannerIsActiveParams) error {
	_, err := q.db.Exec(ctx, updateBannerIsActive, arg.ID, arg.IsActive)
	return err
}
