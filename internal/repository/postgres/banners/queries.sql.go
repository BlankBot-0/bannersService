// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package banners

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addBannerTags = `-- name: AddBannerTags :exec
INSERT INTO banners_tag (banner_id, tag_id)
VALUES ($1::INT, UNNEST($2::INT[]))
`

type AddBannerTagsParams struct {
	BannerID int32
	TagIds   []int32
}

func (q *Queries) AddBannerTags(ctx context.Context, arg AddBannerTagsParams) error {
	_, err := q.db.Exec(ctx, addBannerTags, arg.BannerID, arg.TagIds)
	return err
}

const adminCredentials = `-- name: AdminCredentials :one
SELECT password from credentials
WHERE username = $1::TEXT AND admin = true
`

func (q *Queries) AdminCredentials(ctx context.Context, username string) (string, error) {
	row := q.db.QueryRow(ctx, adminCredentials, username)
	var password string
	err := row.Scan(&password)
	return password, err
}

const checkActiveUserBanner = `-- name: CheckActiveUserBanner :one
SELECT banners.is_active
FROM banners
         JOIN banners_tag ON banners.id = banners_tag.banner_id
WHERE banners_tag.tag_id = $1::INT
  AND banners.feature_id = $2::INT
`

type CheckActiveUserBannerParams struct {
	TagID     int32
	FeatureID int32
}

func (q *Queries) CheckActiveUserBanner(ctx context.Context, arg CheckActiveUserBannerParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkActiveUserBanner, arg.TagID, arg.FeatureID)
	var is_active bool
	err := row.Scan(&is_active)
	return is_active, err
}

const checkBannerId = `-- name: CheckBannerId :one
SELECT EXISTS(SELECT id FROM banners WHERE id = $1::INT)
`

func (q *Queries) CheckBannerId(ctx context.Context, bannerID int32) (bool, error) {
	row := q.db.QueryRow(ctx, checkBannerId, bannerID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkExistsBanner = `-- name: CheckExistsBanner :one
SELECT banners.id
FROM banners
         JOIN banners_tag ON banners.id = banners_tag.banner_id
WHERE banners.feature_id = $1::INT
  AND banners_tag.tag_id = any ($2::INT[])
LIMIT 1
`

type CheckExistsBannerParams struct {
	FeatureID int32
	TagIds    []int32
}

func (q *Queries) CheckExistsBanner(ctx context.Context, arg CheckExistsBannerParams) (int64, error) {
	row := q.db.QueryRow(ctx, checkExistsBanner, arg.FeatureID, arg.TagIds)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createBanner = `-- name: CreateBanner :one
INSERT INTO banners (feature_id, is_active, created_at)
VALUES ($1::INT, $2::BOOLEAN, NOW())
RETURNING id
`

type CreateBannerParams struct {
	FeatureID int32
	IsActive  bool
}

func (q *Queries) CreateBanner(ctx context.Context, arg CreateBannerParams) (int64, error) {
	row := q.db.QueryRow(ctx, createBanner, arg.FeatureID, arg.IsActive)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createBannerInfo = `-- name: CreateBannerInfo :exec
INSERT INTO banners_info (banner_id, updated_at, contents)
VALUES ($1::INT, NOW(), $2)
`

type CreateBannerInfoParams struct {
	BannerID int32
	Contents []byte
}

func (q *Queries) CreateBannerInfo(ctx context.Context, arg CreateBannerInfoParams) error {
	_, err := q.db.Exec(ctx, createBannerInfo, arg.BannerID, arg.Contents)
	return err
}

const deleteBanner = `-- name: DeleteBanner :exec
DELETE
FROM banners
WHERE id = $1::INT
`

func (q *Queries) DeleteBanner(ctx context.Context, bannerID int32) error {
	_, err := q.db.Exec(ctx, deleteBanner, bannerID)
	return err
}

const deleteBannerInfo = `-- name: DeleteBannerInfo :exec
DELETE
FROM banners_info
WHERE banner_id = $1::INT
`

func (q *Queries) DeleteBannerInfo(ctx context.Context, bannerID int32) error {
	_, err := q.db.Exec(ctx, deleteBannerInfo, bannerID)
	return err
}

const deleteBannerTags = `-- name: DeleteBannerTags :exec
DELETE
FROM banners_tag
WHERE banner_id = $1::INT
`

func (q *Queries) DeleteBannerTags(ctx context.Context, bannerID int32) error {
	_, err := q.db.Exec(ctx, deleteBannerTags, bannerID)
	return err
}

const getUserBanner = `-- name: GetUserBanner :one
SELECT banners_info.contents, banners.is_active
FROM banners
         JOIN banners_tag ON banners.id = banners_tag.banner_id
         JOIN banners_info ON banners_tag.banner_id = banners_info.banner_id
WHERE banners_tag.tag_id = $1::INT
  AND banners.feature_id = $2::INT
ORDER BY banners_info.updated_at DESC
LIMIT 1
`

type GetUserBannerParams struct {
	TagID     int32
	FeatureID int32
}

type GetUserBannerRow struct {
	Contents []byte
	IsActive bool
}

func (q *Queries) GetUserBanner(ctx context.Context, arg GetUserBannerParams) (GetUserBannerRow, error) {
	row := q.db.QueryRow(ctx, getUserBanner, arg.TagID, arg.FeatureID)
	var i GetUserBannerRow
	err := row.Scan(&i.Contents, &i.IsActive)
	return i, err
}

const listBannerVersions = `-- name: ListBannerVersions :many
SELECT banners_info.contents,
       banners_info.updated_at
FROM banners
         JOIN banners_info ON banners.id = banners_info.banner_id
WHERE banners.id = $1::INT
LIMIT $3::INT OFFSET $2::INT
`

type ListBannerVersionsParams struct {
	BannerID  int32
	OffsetVal int32
	LimitVal  int32
}

type ListBannerVersionsRow struct {
	Contents  []byte
	UpdatedAt pgtype.Timestamp
}

func (q *Queries) ListBannerVersions(ctx context.Context, arg ListBannerVersionsParams) ([]ListBannerVersionsRow, error) {
	rows, err := q.db.Query(ctx, listBannerVersions, arg.BannerID, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBannerVersionsRow
	for rows.Next() {
		var i ListBannerVersionsRow
		if err := rows.Scan(&i.Contents, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBanners = `-- name: ListBanners :many
SELECT banners.id,
       banners.feature_id,
       bi.contents,
       banners.is_active,
       banners.created_at,
       bi.updated_at,
       array_agg(banners_tag.tag_id)::INT[] as tags
FROM banners
         JOIN banners_tag ON banners.id = banners_tag.banner_id
         JOIN (SELECT banners_info.banner_id, banners_info.contents, banners_info.updated_at
               FROM banners_info
                        RIGHT JOIN (SELECT banner_id, MAX(updated_at) as upd
                                    FROM banners_info
                                    GROUP BY banner_id) as upds ON banners_info.banner_id = upds.banner_id
                   AND banners_info.updated_at = upds.upd) as bi
              ON banners_tag.banner_id = bi.banner_id
WHERE banners_tag.tag_id = $1
   OR $1 IS NULL
    AND banners.feature_id = $2
   OR $2 IS NULL
group by 1, 2, 3, 4, 5, 6
LIMIT $4::INT OFFSET $3::INT
`

type ListBannersParams struct {
	TagID     pgtype.Int4
	FeatureID pgtype.Int4
	OffsetVal int32
	LimitVal  int32
}

type ListBannersRow struct {
	ID        int64
	FeatureID int32
	Contents  []byte
	IsActive  bool
	CreatedAt pgtype.Timestamp
	UpdatedAt pgtype.Timestamp
	Tags      []int32
}

func (q *Queries) ListBanners(ctx context.Context, arg ListBannersParams) ([]ListBannersRow, error) {
	rows, err := q.db.Query(ctx, listBanners,
		arg.TagID,
		arg.FeatureID,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBannersRow
	for rows.Next() {
		var i ListBannersRow
		if err := rows.Scan(
			&i.ID,
			&i.FeatureID,
			&i.Contents,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBannerContents = `-- name: UpdateBannerContents :exec
INSERT INTO banners_info (banner_id, updated_at, contents)
VALUES ($1::INT, NOW(), $2)
`

type UpdateBannerContentsParams struct {
	BannerID int32
	Contents []byte
}

func (q *Queries) UpdateBannerContents(ctx context.Context, arg UpdateBannerContentsParams) error {
	_, err := q.db.Exec(ctx, updateBannerContents, arg.BannerID, arg.Contents)
	return err
}

const updateBannerFeature = `-- name: UpdateBannerFeature :exec
UPDATE banners
SET feature_id = $1::INT
WHERE id = $2::INT
`

type UpdateBannerFeatureParams struct {
	FeatureID int32
	BannerID  int32
}

func (q *Queries) UpdateBannerFeature(ctx context.Context, arg UpdateBannerFeatureParams) error {
	_, err := q.db.Exec(ctx, updateBannerFeature, arg.FeatureID, arg.BannerID)
	return err
}

const updateBannerIsActive = `-- name: UpdateBannerIsActive :exec
UPDATE banners
SET is_active = $1::BOOLEAN
WHERE id = $2::INT
`

type UpdateBannerIsActiveParams struct {
	IsActive bool
	BannerID int32
}

func (q *Queries) UpdateBannerIsActive(ctx context.Context, arg UpdateBannerIsActiveParams) error {
	_, err := q.db.Exec(ctx, updateBannerIsActive, arg.IsActive, arg.BannerID)
	return err
}

const userCredentials = `-- name: UserCredentials :one
SELECT password from credentials
WHERE username = $1::TEXT AND admin = false
`

func (q *Queries) UserCredentials(ctx context.Context, username string) (string, error) {
	row := q.db.QueryRow(ctx, userCredentials, username)
	var password string
	err := row.Scan(&password)
	return password, err
}
